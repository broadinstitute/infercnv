

#' @details
#' The main functions you will need to use are CreateInfercnvObject() and run(infercnv_object).
#' For additional details on running the analysis step by step, please refer to the example vignette.
#' @aliases infercnv-package
"_PACKAGE"


#' The infercnv Class
#'
#' An infercnv object encapsulates the expression data and gene chromosome ordering information
#' that is leveraged by infercnv for data exploration.  The infercnv object is passed among the
#' infercnv data processing and plotting routines.
#'
#' Slots in the infercnv object include:
#'
#' @slot expr.data  <matrix>  the count or expression data matrix, manipulated throughout infercnv ops
#'
#' @slot count.data <matrix>  retains the original count data, but shrinks along with expr.data when genes are removed.
#' 
#' @slot gene_order  <data.frame> chromosomal gene order
#'
#' @slot reference_grouped_cell_indices <list>  mapping [['group_name']] to c(cell column indices) for reference (normal) cells
#'
#' @slot observation_grouped_cell_indices <list> mapping [['group_name']] to c(cell column indices) for observation (tumor) cells
#' 
#' @slot tumor_subclusters <list> stores subclustering of tumors if requested
#'
#' @slot options <list> stores the options relevant to the analysis in itself (in contrast with options relevant to plotting or paths)
#'
#' @slot .hspike a hidden infercnv object populated with simulated spiked-in data
#' 
#' @slot .allele an allele-based object if allele data provided
#' 
#' @export
#'

infercnv <- methods::setClass(
                         "infercnv",
                         slots = c(
                             expr.data = "ANY",
                             count.data = "ANY",
                             gene_order= "data.frame",
                             reference_grouped_cell_indices = "list",
                             observation_grouped_cell_indices = "list",
                             tumor_subclusters  = "ANY",
                             options = "list",
                             .hspike = "ANY") )




#' @title CreateInfercnvObject
#'
#' @param raw_counts_matrix  the matrix of genes (rows) vs. cells (columns) containing the raw counts
#'                           If a filename is given, it'll be read via read.table()
#'                           otherwise, if matrix or Matrix, will use the data directly.
#' 
#' @param raw_allele_matrix the matrix of alternate allele,if provided, containing the raw counts 
#' If a filename is given, it'll be read via read.table()
#' otherwise, if matrix or Matrix, will use the data directly. 
#' 
#' @param raw_coverage_matrix the matrix of coverage allele, if provided, containing the raw counts
#' If a filename is given, it'll be read via read.table()
#' otherwise, if matrix or Matrix, will use the data directly.
#'  
#' @param gene_order_file data file containing the positions of each gene along each chromosome in the genome.
#'
#' @param annotations_file a description of the cells, indicating the cell type classifications
#'
#' @param ref_group_names a vector containing the classifications of the reference (normal) cells to use for infering cnv
#'
#' @param delim delimiter used in the input files
#'
#' @param max_cells_per_group maximun number of cells to use per group. Default=NULL, using all cells defined in the annotations_file. This option is useful for randomly subsetting the existing data for a quicker preview run, such as using 50 cells per group instead of hundreds.
#' 
#' @param min_max_counts_per_cell minimum and maximum counts allowed per cell. Any cells outside this range will be removed from the counts matrix. default=(100, +Inf) and uses all cells. If used, should be set as c(min_counts, max_counts)
#'
#' @param snp_split_by the string used for splitting the rowname of allele matrix (if allele data provided). default = "::"
#' 
#' @param chr_exclude list of chromosomes in the reference genome annotations that should be excluded from analysis.  Default = c('chrX', 'chrY', 'chrM')
#'
#' @description Creation of an infercnv object. This requires the following inputs:
#' A more detailed description of each input is provided below:
#'
#' The raw_counts_matrix:
#'
#'            MGH36_P10_A01 MGH36_P10_E09 MGH36_P3_D05 MGH36_P4_F07 MGH36_P4_G01 ...
#' AL627309.1             0             0            0            1            0
#' CICP27                 0             0           16           71          101
#' AL627309.5             3            34           24           31           12
#' FO538757.1             0             0            2            0            3
#' AP006222.1             2             0            1           11            0
#' ...
#'
#' The raw_allele_matrix (if provided):
#' 
#'               MGH36_P10_A01 MGH36_P10_E09 MGH36_P3_D05 MGH36_P4_F07 MGH36_P4_G01 ...
#' chr1::1543953         0.001             0            0            0            0
#' chr1::1860776         0.000             2            9            0            0
#' chr1::7779884         0.001             4            0            0            0
#' chr1::7780866         0.001             4            0            0            0
#' chr1::7961718         0.000             0            0            3            0
#' ...
#'
#' The raw_coverage_matrix (if provided):
#'
#'               MGH36_P10_A01 MGH36_P10_E09 MGH36_P3_D05 MGH36_P4_F07 MGH36_P4_G01 ...
#' chr1::1543953             1             0            0            0            0
#' chr1::1860776             0             6            9            0            0
#' chr1::7779884             2            12            0            0            0
#' chr1::7780866             2             9            0            0            0
#' chr1::7961718             0             0            0            3            0
#' ...
#' 
#' The gene_order_file, contains chromosome, start, and stop position for each gene, tab-delimited:
#'
#'             chr  start   stop
#' AL627309.1 chr1  89295 133723
#' CICP27     chr1 131025 134836
#' AL627309.5 chr1 141474 173862
#' FO538757.1 chr1 185217 195411
#' AP006222.1 chr1 257864 359681
#' AL732372.2 chr1 365389 522928
#' ...
#' 
#' The annotations_file, containing the cell name and the cell type classification, tab-delimited.
#'
#'                                 V2    V3
#' MGH36_P10_A01 Microglia/Macrophage MGH36
#' MGH36_P10_E09 Microglia/Macrophage MGH36
#' MGH36_P3_D05  Microglia/Macrophage MGH36
#' MGH36_P4_F07             malignant MGH36
#' MGH36_P4_G01             malignant MGH36
#' MGH36_P4_H01             malignant MGH36
#' ...
#'
#'
#' and the ref_group_names vector might look like so:  c("Microglia/Macrophage","Oligodendrocytes (non-malignant)")
#'
#' @return infercnv
#'
#' @export
#'
#' @examples
#' data(infercnv_data_example)
#' data(infercnv_annots_example)
#' data(infercnv_genes_example)
#' data(infercnv_allele_alt_example)
#' data(infercnv_allele_tot_example)
#'
#' infercnv_object_example <- infercnv::CreateInfercnvObject(raw_counts_matrix = infercnv_data_example,
#'                                                           raw_allele_matrix = infercnv_allele_alt_example,
#'                                                           raw_coverage_matrix = infercnv_allele_tot_example,
#'                                                           gene_order_file = infercnv_genes_example,
#'                                                           annotations_file = infercnv_annots_example,
#'                                                           ref_group_names=c("Microglia/Macrophage"),
#'                                                           snp_split_by = "::")
#'


CreateInfercnvObject <- function(raw_counts_matrix,
                                 raw_allele_matrix = NULL,
                                 raw_coverage_matrix = NULL,
                                 gene_order_file,
                                 annotations_file,
                                 ref_group_names,
                                 delim="\t",
                                 max_cells_per_group=NULL,
                                 min_max_counts_per_cell=c(100, +Inf), # can be c(low,high) for colsums
                                 snp_split_by = "::",
                                 chr_exclude=c('chrX', 'chrY', 'chrM') ) {
    
    ## input expression data
    # if (Reduce("|", is(raw_counts_matrix) == "character")) {
    #     flog.info(sprintf("Parsing matrix: %s", raw_counts_matrix)) 
    # 
    #     if (substr(raw_counts_matrix, nchar(raw_counts_matrix)-2, nchar(raw_counts_matrix)) == ".gz") {
    #         raw.data <- read.table(connection <- gzfile(raw_counts_matrix, 'rt'), sep=delim, header=TRUE, row.names=1, check.names=FALSE)
    #         close(connection)
    #         raw.data <- as.matrix(raw.data)
    #     }
    #     else if(substr(raw_counts_matrix, nchar(raw_counts_matrix)-3, nchar(raw_counts_matrix)) == ".rds") {
    #         raw.data <- readRDS(raw_counts_matrix)
    #     }
    #     else {
    #         raw.data <- read.table(raw_counts_matrix, sep=delim, header=TRUE, row.names=1, check.names=FALSE)
    #         raw.data <- as.matrix(raw.data)
    #     }
    # } else if (Reduce("|", is(raw_counts_matrix) %in% c("dgCMatrix", "matrix"))) {
    #     # use as is:
    #     raw.data <- raw_counts_matrix
    # } else if (Reduce("|", is(raw_counts_matrix) %in% c("data.frame"))) {
    #     raw.data <- as.matrix(raw_counts_matrix)
    # } else {
    #     stop("CreateInfercnvObject:: Error, raw_counts_matrix isn't recognized as a matrix, data.frame, or filename")
    # }
    if (!is.null(raw_counts_matrix) & (!is.null(raw_allele_matrix) & !is.null(raw_coverage_matrix))) {
        flog.info("CreateInfercnvObject:: Leveraging both expression and allele data")
        raw.data <- .read_count_matrix(matrix = raw_counts_matrix, delim = delim)
        
        if (is.null(snp_split_by)){
            stop("CreateInfercnvObject:: Error, please specifiy the parameter: snp_split_by to indicate the string used
                 for splitting the rownames of allele matrix")
        }
        raw.allele.alt.data <- .read_count_matrix(matrix = raw_allele_matrix, delim = delim)
        raw.allele.coverage.data <- .read_count_matrix(matrix = raw_coverage_matrix, delim = delim)
        .allele_precheck(raw.allele.alt.data, raw.allele.coverage.data, raw.data)
    } else if(!is.null(raw_counts_matrix)) {
        flog.info("CreateInfercnvObject:: Only Leveraging expression data")
        raw.data <- .read_count_matrix(matrix = raw_counts_matrix, delim = delim)
    }

    ## get gene order info
    if (Reduce("|", is(gene_order_file) == "character")) {
        flog.info(sprintf("Parsing gene order file: %s", gene_order_file))
        gene_order <- read.table(gene_order_file, header=FALSE, row.names=1, sep="\t", check.names=FALSE)
    }
    else if (Reduce("|", is(gene_order_file) %in% c("dgCMatrix", "matrix", "data.frame"))) {
        gene_order <- gene_order_file
    }
    else {
        stop("CreateInfercnvObject:: Error, gene_order_file isn't recognized as a matrix, data.frame, or filename")
    }
    names(gene_order) <- c(C_CHR, C_START, C_STOP)
    if (! is.null(chr_exclude) && any(which(gene_order$chr %in% chr_exclude))) {
        gene_order = gene_order[-which(gene_order$chr %in% chr_exclude),]
    }
    
    ## read annotations file
    if (Reduce("|", is(annotations_file) == "character")) {
        flog.info(sprintf("Parsing cell annotations file: %s", annotations_file))
        input_classifications <- read.table(annotations_file, header=FALSE, row.names=1, sep=delim, stringsAsFactors=FALSE, colClasses = c('character', 'character'))
    }
    else if (Reduce("|", is(annotations_file) %in% c("dgCMatrix", "matrix", "data.frame"))) {
        input_classifications <- annotations_file
    }
    else {
        stop("CreateInfercnvObject:: Error, annotations_file isn't recognized as a matrix, data.frame, or filename")
    }
    
    ## just in case the first line is a default header, remove it:
    if (rownames(input_classifications)[1] == "V1") {
        input_classifications = input_classifications[-1, , drop=FALSE]
    }
    
    ## make sure all reference samples are accounted for:
    if (! all( rownames(input_classifications) %in% colnames(raw.data)) ) {
        
        missing_cells <- rownames(input_classifications)[ ! ( rownames(input_classifications) %in% colnames(raw.data) ) ]

        error_message <- paste("Please make sure that all the annotated cell ",
                               "names match a sample in your data matrix. ",
                               "Attention to: ",
                               paste(missing_cells, collapse=","))
        stop(error_message)
    }

    ## extract the genes indicated in the gene ordering file:
    order_ret <- .order_reduce(data=raw.data, genomic_position=gene_order)
    
    num_genes_removed = dim(raw.data)[1] - dim(order_ret$exp)[1]
    
    if (num_genes_removed > 0) {
        flog.info(paste("num genes removed taking into account provided gene ordering list: ",
                        num_genes_removed,
                        " = ",
                        num_genes_removed / dim(raw.data)[1] * 100,
                        "% removed.", sep=""))
    }
    
    raw.data <- order_ret$expr
    input_gene_order <- order_ret$order
    input_gene_order[["chr"]] = droplevels(input_gene_order[["chr"]])
    
    if(is.null(raw.data)) {
        error_message <- paste("None of the genes in the expression data",
                               "matched the genes in the reference genomic",
                               "position file. Analysis Stopped.")
        stop(error_message)
    }
    
    ## Determine if we need to do filtering on counts per cell
    if (is.null(min_max_counts_per_cell)) {
        min_max_counts_per_cell = c(1, +Inf)
    }

    min_counts_per_cell = max(1, min_max_counts_per_cell[1])  # so that it is always at least 1
    max_counts_per_cell = min_max_counts_per_cell[2]

    cs = colSums(raw.data)

    cells.keep <- which(cs >= min_counts_per_cell & cs <= max_counts_per_cell)

    n_orig_cells <- ncol(raw.data)
    n_to_remove <- n_orig_cells - length(cells.keep)
    
    flog.info(sprintf("-filtering out cells < %g or > %g, removing %g %% of cells",
                      min_counts_per_cell,
                      max_counts_per_cell,
                      n_to_remove/n_orig_cells * 100) )
    
    raw.data <- raw.data[, cells.keep]
    
    input_classifications <- input_classifications[ rownames(input_classifications) %in% colnames(raw.data), , drop=FALSE]

    orig_ref_group_names = ref_group_names
    ref_group_names <- ref_group_names[ ref_group_names %in% unique(input_classifications[,1]) ]
    if (! all.equal(ref_group_names, orig_ref_group_names)) {
        flog.warn(sprintf("-warning, at least one reference group has been removed due to cells lacking: %s",
                          orig_ref_group_names[! orig_ref_group_names %in% ref_group_names ] ))
    }

    
    
    if (! is.null(max_cells_per_group)) {
        ## trim down where needed.
        grps = split(input_classifications, input_classifications[,1])
        newdf = NULL
        for (grp in names(grps)) {
            df = grps[[grp]]
            if (dim(df)[1] > max_cells_per_group) {
                flog.info(sprintf("-reducing number of cells for grp %s from %g to %g",
                                  grp, dim(df)[1], max_cells_per_group))
                grps[[grp]] = df[sample(seq_len(dim(df)[1]), max_cells_per_group),,drop=FALSE]
            }
        }
        input_classifications = data.frame(Reduce(rbind, grps))
    }
        
    ## restrict expression data to the annotated cells.
    raw.data <- raw.data[,colnames(raw.data) %in% rownames(input_classifications)]
        
    ## reorder cell classifications according to expression matrix column names
    input_classifications <- input_classifications[order(match(row.names(input_classifications), colnames(raw.data))), , drop=FALSE]

    
    ## get indices for reference cells
    ref_group_cell_indices = list()
    for (name_group in ref_group_names) {
        cell_indices = which(input_classifications[,1] == name_group)
        names(cell_indices) = rownames(input_classifications)[cell_indices]
        
        if (length(cell_indices) == 0 ) {
            stop(sprintf("Error, not identifying cells with classification %s", name_group))
        }
        ref_group_cell_indices[[ name_group ]] <- cell_indices
    }
    
    ## rest of the cells are the 'observed' set.
    all_group_names <- unique(input_classifications[,1])
    obs_group_names <- sort(setdiff(all_group_names, ref_group_names))

    ## define groupings according to the observation annotation names
    
    obs_group_cell_indices = list()
    for (name_group in obs_group_names) {
        cell_indices = which(input_classifications[,1] == name_group)
        names(cell_indices) = rownames(input_classifications)[cell_indices]
        obs_group_cell_indices[[ toString(name_group) ]] <- cell_indices
    }

    if ((2*ncol(raw.data)) >=  10^getOption("scipen")) {
        flog.warn(paste0("Please use \"options(scipen = 100)\" before running infercnv ",
                         "if you are using the analysis_mode=\"subclusters\" option or ",
                         "you may encounter an error while the hclust is being generated."))
    }
    
    ## allele data if provided
    if (exists("raw.allele.alt.data") & exists("raw.allele.coverage.data")){
        raw.allele.alt.data <- raw.allele.alt.data[, colnames(raw.data)]
        raw.allele.coverage.data <-raw.allele.coverage.data[, colnames(raw.data)]
        
        processed_allele_data <- .allele_preprocess(raw.allele.alt.data, raw.allele.coverage.data)
        raw.allele.alt.data <- processed_allele_data$allele.data
        raw.allele.coverage.data <- processed_allele_data$coverage.data
        
        order_ret_allele <- .order_reduce_allele(raw.allele.alt.data,
                                                 raw.allele.coverage.data,
                                                 snp_split_by,
                                                 input_gene_order)
        raw.allele.alt.data <- order_ret_allele$allele.data
        raw.allele.coverage.data <- order_ret_allele$coverage.data
        snps <- order_ret_allele$snps
        
        object <- new(
            Class = "infercnv_allele",
            expr.data = raw.data, 
            count.data = raw.data,
            gene_order = input_gene_order,
            reference_grouped_cell_indices = ref_group_cell_indices,
            observation_grouped_cell_indices = obs_group_cell_indices,
            tumor_subclusters = NULL,
            allele.alt.data = raw.allele.alt.data,
            allele.coverage.data = raw.allele.coverage.data,
            SNP_info = snps,
            allele.gene_order = order_ret_allele$gene_order,
            options = list("chr_exclude" = chr_exclude,
               "max_cells_per_group" = max_cells_per_group,
               "min_max_counts_per_cell" = min_max_counts_per_cell,
               "counts_md5" = digest(raw.data)),
            .hspike = NULL)

        validate_infercnv_allele_obj(object)
    }
    else{

        object <- new(
            Class = "infercnv",
            expr.data = raw.data, 
            count.data = raw.data,
            gene_order = input_gene_order,
            reference_grouped_cell_indices = ref_group_cell_indices,
            observation_grouped_cell_indices = obs_group_cell_indices,
            tumor_subclusters = NULL,
            options = list("chr_exclude" = chr_exclude,
                           "max_cells_per_group" = max_cells_per_group,
                           "min_max_counts_per_cell" = min_max_counts_per_cell,
                           "counts_md5" = digest(raw.data)),
            .hspike = NULL)

    }
    validate_infercnv_obj(object)

    
    return(object)
}

# Read a count matrix given specific path or object

# matrix A full path to the file

# delim A character used to separate contents using read.table

# name A character used to label datasets

.read_count_matrix <- function(matrix, delim){
    #browser()
    if (Reduce("|", is(matrix) == "character")) {
        flog.info(sprintf("Parsing matrix: %s ...", matrix)) 
        if (substr(matrix, nchar(matrix)-2, nchar(matrix)) == ".gz") {
            raw.data <- read.table(connection <- gzfile(matrix, 'rt'), sep=delim, header=TRUE, row.names=1, check.names=FALSE) %>% as.matrix() %>% Matrix(sparse=T)
            close(connection)
            return(Matrix(raw.data, sparse=T))
        }
        else if(substr(matrix, nchar(matrix)-3, nchar(matrix)) == ".rds") {
            return(readRDS(matrix))
        }
        else {
            raw.data <- read.table(matrix, sep=delim, header=TRUE, row.names=1, check.names=FALSE) %>% as.matrix() %>% Matrix(sparse=T)
            return(Matrix(raw.data, sparse=T))
        }
    } 
    else if (Reduce("|", is(matrix) %in% c("matrix"))) {
        return(Matrix(matrix, sparse=T))
    }
    else if (Reduce("|", is(matrix) %in% c("dgCMatrix"))) {
        return(matrix)
    }
    else if (Reduce("|", is(matrix) %in% c("data.frame"))) {
        return(Matrix(as.matrix(matrix), sparse=T))
    } 
    else {
        stop(sprintf("CreateInfercnvObject:: Error, %s isn't recognized as a matrix, data.frame, or filename",
                     matrix))
    }
}

.allele_precheck <- function(allele.data, coverage.data, expression_data){
    if(!isTRUE(all.equal(rownames(allele.data), rownames(coverage.data))) |
       !isTRUE(all.equal(colnames(allele.data), colnames(coverage.data)))){
        stop("CreateInfercnvAlleleObject:: Error, the dimension of allele data is not same as the coverage data")
    }
    
    if(mean(colnames(expression_data) %in% colnames(allele.data)) != 1){
        missing_cells <- colnames(expression_data)[ ! ( colnames(expression_data) %in% colnames(allele.data) ) ]
        
        error_message <- paste("Please make sure that all cells in expression data ",
                               "can be found in allele data. ",
                               "Attention to: ",
                               paste(missing_cells, collapse=","))
        stop(error_message)
    }
    return()
}

.allele_preprocess <- function(allele.data, coverage.data){
    to_remove = allele.data@x < 1
    if (any(to_remove)) {
        allele.data@x[to_remove] = 0
        allele.data = drop0(allele.data)
    }


    filter_index <- Matrix::rowSums(coverage.data) != 0
    remove_len = nrow(coverage.data) - length(filter_index)

    if(remove_len > 0){
        flog.info(sprintf("WARNING! %s SNPs with zero coverage will be removed", remove_len))
        allele.data <- allele.data[filter_index,]
        coverage.data <- coverage.data[filter_index,]
    }
    return(list("allele.data" = allele.data,
                "coverage.data" = coverage.data))
}

# Order the data and subset the data to data in the genomic position file.
#
# Args:
# @param data Data (expression) matrix where the row names should be in
#                 the row names of the genomic_position file.
# @param genomic_position Data frame read in from the genomic position file
#
# @return Returns a matrix of expression in the order of the
#            genomic_position file. NULL is returned if the genes in both
#            data parameters do not match.
#

.order_reduce <- function(data, genomic_position){
    flog.info(paste("::order_reduce:Start.", sep=""))
    ret_results <- list(expr=NULL, order=NULL, chr_order=NULL)
    if (is.null(data) || is.null(genomic_position)){
        return(ret_results)
    }

    # Drop pos_gen entries that are position 0
    remove_by_position <- -1 * which(genomic_position[2] + genomic_position[3] == 0)
    if (length(remove_by_position)) {
        flog.debug(paste("::process_data:order_reduce: removing genes specified by pos == 0, count: ",
                                length(remove_by_position), sep=""))

        genomic_position <- genomic_position[remove_by_position, , drop=FALSE]
    }

    # Reduce to genes in pos file

    flog.debug(paste("::process_data:order_reduce: gene identifers in expression matrix: ",
                            row.names(data), collapse="\n", sep=""))
    flog.debug(paste("::process_data:order_reduce: gene identifers in genomic position table: ",
                            row.names(data), collapse="\n", sep=""))



    keep_genes <- intersect(row.names(data), row.names(genomic_position))
        
    flog.debug(paste("::process_data:order_reduce: keep_genes size: ", length(keep_genes),
                     sep=""))
    
    # Keep genes found in position file
    if (length(keep_genes)) {
        ret_results$expr <- data[match(keep_genes, rownames(data)), , drop=FALSE]
        ret_results$order <- genomic_position[match(keep_genes, rownames(genomic_position)), , drop=FALSE]
    } else {
        flog.info(paste("::process_data:order_reduce:The position file ",
                        "and the expression file row (gene) names do not match."))
        return(list(expr=NULL, order=NULL, chr_order=NULL))
    }
    
    ## ensure expr and order match up!
    if (isTRUE(all.equal(rownames(ret_results$expr), rownames(ret_results$order)))) {
        flog.info(".order_reduce(): expr and order match.")
    }
    else {
        stop("Error, .order_reduce(): expr and order don't match! must debug")
    }
        
    # Set the chr to factor so the order can be arbitrarily set and sorted.
    chr_levels <- unique(genomic_position[[C_CHR]])
    ret_results$order[[C_CHR]] <- factor(ret_results$order[[C_CHR]],
                                   levels=chr_levels)
    
    # Sort genomic position file and expression file to genomic position file
    # Order genes by genomic region
    order_names <- row.names(ret_results$order)[with(ret_results$order, order(chr,start,stop))]
    
    ret_results$expr <- ret_results$expr[match(order_names, rownames(ret_results$expr)), , drop=FALSE] #na.omit is to rid teh duplicate gene entries (ie. Y_RNA, snoU13, ...) if they should exist.
    
    # This is the contig order, will be used in visualization.
    # Get the contig order in the same order as the genes.
    ret_results$order <- ret_results$order[match(order_names, rownames(ret_results$order)), , drop=FALSE]
    ret_results$chr_order <- ret_results$order[1]
    
    # Remove any gene without position information
    # Genes may be sorted correctly by not have position information
    # Here they are removed.
    flog.info(paste("::process_data:order_reduce:Reduction from positional ",
                           "data, new dimensions (r,c) = ",
                           paste(dim(data), collapse=","),
                           " Total=", sum(data),
                           " Min=", min(data),
                           " Max=", max(data),
                           ".", sep=""))
    flog.debug(paste("::process_data:order_reduce end."))
    return(ret_results)
}

.order_reduce_allele <- function(allele.data, 
                                 coverage.data, 
                                 snp_split_by, 
                                 gene_annot){
    #browser()
    ## Initialize SNP sites
    snps.df <- rownames(allele.data) 
    snps.df <- data.frame(do.call(rbind,strsplit(snps.df,snp_split_by)), stringsAsFactors=F)
    
    if(ncol(snps.df)==2) {
        snps.df <- cbind(snps.df, snps.df[,2])
    }
    colnames(snps.df) <- c(C_CHR,C_START,C_STOP)
    
    if(!grepl(C_CHR, snps.df[1,1])) {
        snps.df[,1] <- paste0(C_CHR, snps.df[,1])
    }
    snps.df[[C_START]] <- as.integer(snps.df[[C_START]])
    snps.df[[C_STOP]] <- as.integer(snps.df[[C_STOP]])
    
    ## create a Granges object for SNP
    snps <- GRanges(snps.df[[C_CHR]],
                    IRanges(snps.df[[C_START]], 
                            snps.df[[C_STOP]]))
    
    names(snps) <- rownames(allele.data) <- 
        rownames(coverage.data)  <-
        rownames(snps.df) <-
        #apply(snps.df, 1, paste0, collapse=":")
        paste0(snps.df[[C_CHR]], ":",
               snps.df[[C_START]], ":",
               snps.df[[C_STOP]])
    
    snps <- snps %>% sortSeqlevels() %>% sort()
    
    gene_ref <- GRanges(gene_annot[[C_CHR]],
                        IRanges(as.numeric(as.character(gene_annot[[C_START]])),
                                as.numeric(as.character(gene_annot[[C_STOP]]))))
    # gene_ref$gene_name <- gene_annot %>% rownames()
    
    snps <- snps[seqnames(snps) %>% as.character() %in% unique(gene_annot[[C_CHR]])]
    # snp2gene_index <- nearest(snps, gene_ref)
    # snps$gene_name <- gene_ref$gene_name[snp2gene_index]
    
    ## old changes: filter those snps that do not map up with gene order
    # flog.info(sprintf("%s%% snps filtered out due to inconsistent mapping with gene regions",
    #                   round(mean(!snps %over% gene_ref)*100, 2)))
    # snps <- snps[snps %over% gene_ref]
    
    # snp_map <- findOverlaps(snps, gene_ref)
    # if(mean(duplicated(queryHits(snp_map))) > 0){
    # 
    #     flog.info("snps mapping with multiple genes will be mapped with its first match")
    #     snp_map <- snp_map[!duplicated(queryHits(snp_map))]
    # 
    # }
    # snps <- snps[queryHits(snp_map)]
    # snps$gene_name <- gene_ref$gene_name[subjectHits(snp_map)]
    # snps.df <- snps.df[names(snps),]
    # 
    # n_chr <- strsplit(snps.df[[C_CHR]],"chr") %>% 
    #     unlist %>% as.numeric() %>% na.omit() %>% 
    #     unique() %>% sort(decreasing = FALSE)
    # snps.df[[C_CHR]] <- factor(snps.df[[C_CHR]], levels = paste0("chr",n_chr))
    
    return(list("allele.data" = allele.data[names(snps),],
                "coverage.data" = coverage.data[names(snps),],
                "snps" = snps,
                "gene_order" = snps.df[names(snps),]))
}


#' @title remove_genes()
#'
#' @description infercnv obj accessor method to remove genes from the matrices
#'
#' @param infercnv_obj infercnv object
#' 
#' @param gene_indices_to_remove matrix indices for genes to remove
#'
#' @return infercnv_obj
#'
#' @keywords internal
#' @noRd
#'

remove_genes <- function(infercnv_obj, gene_indices_to_remove) {

    infercnv_obj@expr.data <- infercnv_obj@expr.data[ -1 * gene_indices_to_remove, , drop=FALSE]
    
    infercnv_obj@count.data <- infercnv_obj@count.data[ -1 * gene_indices_to_remove, , drop=FALSE]

    infercnv_obj@gene_order <- infercnv_obj@gene_order[ -1 * gene_indices_to_remove, , drop=FALSE] 
    infercnv_obj@gene_order[["chr"]] = droplevels(infercnv_obj@gene_order[["chr"]])
    
    validate_infercnv_obj(infercnv_obj)
    
    return(infercnv_obj)
}


#' @title validate_infercnv_obj()
#'
#' @description validate an infercnv_obj
#' ensures that order of genes in the @gene_order slot match up perfectly with the gene rows in the @expr.data matrix.
#' Otherwise, throws an error and stops execution.
#'
#' @param infercnv_obj infercnv_object
#'
#' @return none
#'

validate_infercnv_obj <- function(infercnv_obj) {
    
    flog.info("validating infercnv_obj")
    
    if (isTRUE(all.equal(rownames(infercnv_obj@expr.data), rownames(infercnv_obj@gene_order)))) {
        # all good.
        return();
        
    }
    else {
        
        flog.error("hmm.... rownames(infercnv_obj@expr.data != rownames(infercnv_obj@gene_order))")
        broken.infercnv_obj = infercnv_obj
        save('broken.infercnv_obj', file="broken.infercnv_obj")
        
    }
    
    
    genes = setdiff(rownames(infercnv_obj@expr.data), rownames(infercnv_obj@gene_order))
    if (length(genes) != 0) {
        flog.error(paste("The following genes are in infercnv_obj@expr.data and not @gene_order:", paste(genes, collapse=","),
                         sep=" "))
        
    }
    
    genes = setdiff(rownames(infercnv_obj@gene_order), rownames(infercnv_obj@expr.data))
    if (length(genes) != 0) {
        flog.error(paste("The following genes are in @gene_order and not infercnv_obj@expr.data:", paste(genes, collapse=","),
                         sep=" "))
        
    }
    
    stop("Problem detected w/ infercnv_obj")
    
}


get_cell_name_by_grouping <- function(infercnv_obj) {

    cell_name_groupings = list()
    
    groupings = c(infercnv_obj@reference_grouped_cell_indices, infercnv_obj@observation_grouped_cell_indices)

    for (group_name in names(groupings)) {

        cell_names = colnames(infercnv_obj@expr.data[, groupings[[ group_name ]] ] )

        cell_name_groupings[[ group_name ]] = cell_names

    }

    return(cell_name_groupings)
}


has_reference_cells <- function(infercnv_obj) {
    return(length(infercnv_obj@reference_grouped_cell_indices) != 0)
}
